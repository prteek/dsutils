#!/usr/bin/env python3

import ray
import subprocess
import argparse
import sys
from typing import List, Union
import time
import socket
import json

class RayHelper:
    def __init__(self, ray_port: str = "9339", redis_pass: str = "redis_password"):
        self.ray_port = ray_port
        self.redis_pass = redis_pass
        self.resource_config = self.get_resource_config()
        self.master_host = self.resource_config["hosts"][0]
        self.n_hosts = len(self.resource_config["hosts"])

    @staticmethod
    def get_resource_config():
        resource_config_path = "/opt/ml/config/resourceconfig.json"
        with open(resource_config_path, "r") as f:
            return json.load(f)

    def _get_ip_from_host(self):
        ip_wait_time = 200
        counter = 0
        ip = ""

        while counter < ip_wait_time and ip == "":
            try:
                ip = socket.gethostbyname(self.master_host)
                break
            except TypeError:
                counter += 1
                time.sleep(1)

        if counter == ip_wait_time and ip == "":
            raise Exception(
                "Exceeded max wait time of {}s for hostname resolution".format(
                    ip_wait_time
                )
            )
        return ip

    def start_ray(self):
        master_ip = self._get_ip_from_host()

        if self.resource_config["current_host"] == self.master_host:
            if ray.is_initialized():
                print("There is a Ray cluster already running. Shutting it down.")
                ray.shutdown()
                time.sleep(5)
            output = subprocess.run(
                [
                    "ray",
                    "start",
                    "--head",
                    "-vvv",
                    "--port",
                    self.ray_port,
                    "--redis-password",
                    self.redis_pass,
                    "--include-dashboard",
                    "false",
                ],
                stdout=subprocess.PIPE,
            )
            print(output.stdout.decode("utf-8"))
            ray.init(address="auto", include_dashboard=False)
            self._wait_for_workers()
            print("All workers present and accounted for")
            print(ray.cluster_resources())

        else:
            time.sleep(10)
            output = subprocess.run(
                [
                    "ray",
                    "start",
                    f"--address={master_ip}:{self.ray_port}",
                    "--redis-password",
                    self.redis_pass,
                    "--block",
                ],
                stdout=subprocess.PIPE,
            )
            print(output.stdout.decode("utf-8"))
            sys.exit(0)

    def _wait_for_workers(self, timeout=60):
        print(f"Waiting {timeout} seconds for {self.n_hosts} nodes to join")

        while len(ray.nodes()) < self.n_hosts:
            print(f"{len(ray.nodes())} nodes connected to cluster")
            time.sleep(5)
            timeout -= 5
            if timeout == 0:
                raise Exception("Max timeout for nodes to join exceeded")

@ray.remote
def run_command(command: Union[str, List[str]]) -> int:
    """
    Execute a shell command or a Python script.
    """
    try:
        result = subprocess.run(command, shell=True, check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        print(result.stdout.decode('utf-8'))
        return result.returncode
    except subprocess.CalledProcessError as e:
        print(e.stderr.decode('utf-8'), file=sys.stderr)
        return e.returncode

def parse_input_file(input_file: str) -> List[str]:
    """
    Parse input file to get a list of commands or arguments.
    """
    with open(input_file, 'r') as file:
        return [line.strip() for line in file.readlines()]

def main():
    parser = argparse.ArgumentParser(description="A GNU Parallel-like tool for Ray cluster. Can accept either textfile or piped input for iterables and passes inputs to commands using {} placeholder. (e.g.: seq 10 | rayrun  'python script.py {} arg2 | head -n 5')")
    parser.add_argument('input', help="Input file with commands or arguments.")
    parser.add_argument('-c', '--command', required=True, help="Command template with '{}' as placeholder for input. (e.g. 'python script.py {} arg2 | head -n 10' )")
    parser.add_argument('-t', '--output-code', action='store_true', help="Output the command code that will be executed ({} means input)")
    parser.add_argument('-m', '--mode', choices=["local", "sagemaker"], default='local', help="Mode in which ray should start cluster. Using 'sagemaker' allows connecting to multiple the instances available for the job by using their IP Configs")

    args = parser.parse_args()

    if args.input == '-':
        input_list = [line.strip() for line in sys.stdin]
    else:
        input_list = parse_input_file(args.input)

    command_template = args.command

    # Output the command code if -t flag is provided
    if args.output_code:
        print(command_template, file=sys.stderr)

    # Initialize Ray (either local or use Sagemaker instance config to connect to all instances)
    if args.mode == 'local':
        ray.init()
    else:
        ray_helper = RayHelper()
        ray_helper.start_ray()

    tasks = []
    for input_item in input_list:
        command = command_template.replace('{}', input_item)
        tasks.append(run_command.remote(command))

    # Wait for all tasks to complete and get results, then shutdown ray
    ray.get(tasks)
    ray.shutdown()

if __name__ == '__main__':

    main()
