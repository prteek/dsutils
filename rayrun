#!/usr/bin/env python3

import ray
import subprocess
import argparse
import sys
from typing import List, Union
import time
import socket
import json
import os

class RayHelper:
    def __init__(self, ray_port: str = "9339", redis_pass: str = "redis_password"):
        self.ray_port = ray_port
        self.redis_pass = redis_pass
        self.resource_config = self.get_resource_config()
        self.master_host = self.resource_config["hosts"][0]
        self.n_hosts = len(self.resource_config["hosts"])

    @staticmethod
    def get_resource_config():
        resource_config_path = "/opt/ml/config/resourceconfig.json"
        with open(resource_config_path, "r") as f:
            return json.load(f)

    def _get_ip_from_host(self):
        ip_wait_time = 200
        counter = 0
        ip = ""

        while counter < ip_wait_time and ip == "":
            try:
                ip = socket.gethostbyname(self.master_host)
                break
            except TypeError:
                counter += 1
                time.sleep(1)

        if counter == ip_wait_time and ip == "":
            raise Exception(
                "Exceeded max wait time of {}s for hostname resolution".format(
                    ip_wait_time
                )
            )
        return ip

    def start_ray(self):
        master_ip = self._get_ip_from_host()

        if self.resource_config["current_host"] == self.master_host:
            if ray.is_initialized():
                print("There is a Ray cluster already running. Shutting it down.")
                ray.shutdown()
                time.sleep(5)
            output = subprocess.run(
                [
                    "ray",
                    "start",
                    "--head",
                    "-vvv",
                    "--port",
                    self.ray_port,
                    "--redis-password",
                    self.redis_pass,
                    "--include-dashboard",
                    "false",
                ],
                stdout=subprocess.PIPE,
            )
            print(output.stdout.decode("utf-8"))
            ray.init(address="auto", include_dashboard=False)
            self._wait_for_workers()
            print("All workers present and accounted for")
            print(ray.cluster_resources())

        else:
            time.sleep(10)
            output = subprocess.run(
                [
                    "ray",
                    "start",
                    f"--address={master_ip}:{self.ray_port}",
                    "--redis-password",
                    self.redis_pass,
                    "--block",
                ],
                stdout=subprocess.PIPE,
            )
            print(output.stdout.decode("utf-8"))
            sys.exit(0)

    def _wait_for_workers(self, timeout=60):
        print(f"Waiting {timeout} seconds for {self.n_hosts} nodes to join")

        while len(ray.nodes()) < self.n_hosts:
            print(f"{len(ray.nodes())} nodes connected to cluster")
            time.sleep(5)
            timeout -= 5
            if timeout == 0:
                raise Exception("Max timeout for nodes to join exceeded")

@ray.remote
def run_command(command:str, output_dir):
    """
    Execute a shell command or a Python script.
    """
    if output_dir:
        output_file = os.path.join(output_dir, "stdout")
        error_file = os.path.join(output_dir, "stderr")
        try:
            with open(output_file, 'w') as out_f:
                result = subprocess.run(command, shell=True, check=True, stdout=out_f, stderr=subprocess.PIPE)  # Capture stderr in the result object
            return None
        except subprocess.CalledProcessError as e:
            # Write the error message to the error file and print to stderr
            with open(error_file, 'w') as err_f:
                err_f.write(e.stderr.decode('utf-8'))
            print(e.stderr.decode('utf-8'), file=sys.stderr)
            return e.returncode
    else:
        try:
            result = subprocess.run(command, shell=True, check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            print(result.stdout.decode('utf-8'), file=sys.stdout)
            return result.returncode
        except subprocess.CalledProcessError as e:
            print(e.stderr.decode('utf-8'), file=sys.stderr)
            return e.returncode

def parse_input_file(input_file: str) -> List[str]:
    """
    Parse input file to get a list of commands or arguments.
    """
    with open(input_file, 'r') as file:
        return [line.strip() for line in file.readlines()]

def main():
    parser = argparse.ArgumentParser(description="A GNU Parallel-like tool for Ray cluster. Can accept either textfile or piped input for iterables and passes inputs to commands using {} placeholder. (e.g.: seq 10 | rayrun  'python script.py {} arg2 | head -n 5')")
    parser.add_argument('command', help="Command template with '{}' as placeholder for input. (e.g. 'python script.py {} arg2 | head -n 10' )")
    parser.add_argument('-t', '--output-code', action='store_true', help="Output the command code that will be executed.")
    parser.add_argument('--results', default=None, help="Directory to save the output and error files for each command.")
    parser.add_argument('-m', '--mode', choices=["local", "sagemaker"], default='local', help="Mode in which ray should start cluster. Using 'sagemaker' allows connecting to multiple the instances available for the job by using their IP Configs")

    args = parser.parse_args()

    input_list = [line.strip() for line in sys.stdin]
    command_template = args.command

    # Output the command code if -t flag is provided
    if args.output_code:
        print(command_template, file=sys.stderr)

    # Initialize Ray (either local or use Sagemaker instance config to connect to all instances)
    if args.mode == 'local':
        ray.init()
    else:
        ray_helper = RayHelper()
        ray_helper.start_ray()

    tasks = []
    for input_item in input_list:
        command = command_template.replace('{}', input_item).replace('{/}', os.path.basename(input_item))

        if args.results:
            if not os.path.exists(args.results): os.mkdir(args.results)
            output_dir = os.path.join(args.results, f"{input_item.replace('/', '+z')}")
            if not os.path.exists(output_dir): os.mkdir(output_dir)
        else:
            output_dir = None

        tasks.append(run_command.remote(command, output_dir))

    # Wait for all tasks to complete and get results, then shutdown ray
    ray.get(tasks)
    ray.shutdown()

if __name__ == '__main__':

    main()
